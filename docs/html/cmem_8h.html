<!--
/*
 *  Copyright 2013 by Texas Instruments Incorporated .
 *  
 */
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Linux Utils Application Programming Interface (API): cmem.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Linux Utils Application Programming Interface (API)
   &#160;<span id="projectnumber">linuxutils-m06</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_27d817bd5eaa0acab6cd26f7ad1c2536.html">ti</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cmem.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Describes the interface to the contiguous memory allocator. </p>
<p>The cmem user interface library wraps file system calls to an associated kernel module (cmemk.ko), which needs to be loaded in order for calls to this library to succeed.</p>
<p>The following is an example of installing the cmem kernel module:</p>
<pre class="fragment">/sbin/insmod cmemk.ko pools=4x30000,2x500000 phys_start=0x0 phys_end=0x3000000 </pre><ul>
<li>phys_start and phys_end must be specified in hexadecimal format</li>
<li>phys_start is "inclusive" and phys_end is "exclusive", i.e., phys_end should be "end address + 1".</li>
<li>pools must be specified using decimal format (for both number and size), since using hexadecimal format would visually clutter the specification due to the use of "x" as a token separator</li>
<li>it's possible to insmod cmemk.ko without specifying any memory blocks, in which case <a class="el" href="group__ti___c_m_e_m.html#gaccb7428817085e56d482f2c722a6e35a" title="Get the physical address of a contiguous buffer.">CMEM_getPhys()</a> and CMEM_cache*() APIs can still be utilized by an application, and CMA-based allocations can still be accomplished (by using blockid as CMEM_CMABLOCKID).</li>
</ul>
<p>This particular command creates 2 pools. The first pool is created with 4 buffers of size 30000 bytes and the second pool is created with 2 buffers of size 500000 bytes. The CMEM pool buffers start at 0x0 and end at 0x2FFFFFF (max).</p>
<p>There is also support for a 2nd contiguous memory block to be specified, with all the same features supported for the 2nd block as with the 1st. This 2nd block is specified with *_1 parameters. The following example expands upon the first example above:</p>
<pre class="fragment">/sbin/insmod cmemk.ko pools=4x30000,2x500000 phys_start=0x0 phys_end=0x3000000
    pools_1=4x65536 phys_start_1=0x80000000 phys_end_1=0x80010000 </pre><p>This particular command, in addition to the pools explained above, creates 1 pool (with 4 buffers of size 64KB) in a 2nd memory block which starts at 0x80000000 and ends at 0x8000FFFF (specified as "end + 1" on the insmod command).</p>
<p>In order to access this 2nd memory block, new APIs have been added to CMEM which allow specification of the block ID.</p>
<p>There are two more configuration "switches" for the cmemk.ko kernel module, which can be specified on the 'insmod' (or 'modprobe') command lines: useHeapIfPoolUnavailable=[0|1] allowOverlap=[0|1]</p>
<p>'useHeapIfPoolUnavailable', when set to 1, will cause pool-based allocations to fallback to a heap-based allocation if no pool buffer of sufficient size is available (the CMEM heap is described below).</p>
<p>'allowOverlap', when set to 1, causes cmemk.ko to not fail when it detects that a CMEM memory block location conflicts with the Linux kernel memory, and instead an informational message is printed on the console. When set to 0, cmemk.ko insertion will fail when this condition is detected. The overlap detection is fairly crude, however, checking only that the end of the kernel's memory (assigned by way of the u-boot 'bootargs' parameter "mem=##M") is not above the beginning location of a CMEM memory block. For example, on most TI processor-based systems the kernel's memory starts at 0x80000000 and ends at (0x80000000 + ##M), so a CMEM block starting at 0x1000 would be detected as overlapping since the beginning location of that block is not greater than the end location of the kernel's memory. To allow this situation, cmemk.ko should be inserted using "allowOverlap=1".</p>
<p>Pool buffers are aligned on a module-dependent boundary, and their sizes are rounded up to this same boundary. This applies to each buffer within a pool. The total space used by an individual pool will therefore be greater than (or equal to) the exact amount requested in the installation of the module.</p>
<p>The poolid used in the driver calls would be 0 for the first pool and 1 for the second pool.</p>
<p>Pool allocations can be requested explicitly by pool number, or more generally by just a size. For size-based allocations, the pool which best fits the requested size is automatically chosen. Some CMEM APIs (newer ones) accept a blockid as a parameter, in order to specify which of the multiple blocks to operate on. For 'legacy' APIs (ones that existed before the support for multiple blocks) where a blockid is still needed, block 0 is assumed.</p>
<p>There is also support for a general purpose heap. In addition to the 2 pools described above, a general purpose heap block is created from which allocations of any size can be requested. Internally, allocation sizes are rounded up to a module-dependent boundary and allocation addresses are aligned either to this same boundary or to the requested alignment (whichever is greater).</p>
<p>The size of the heap block is the amount of CMEM memory remaining after all pool allocations. If more heap space is needed than is available after pool allocations, you must reduce the amount of CMEM memory granted to the pools.</p>
<p>Buffer allocation is tracked at the file descriptor level by way of a 'registration' list. The initial allocator of a buffer (the process that calls <a class="el" href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a" title="Allocate memory of a specified size.">CMEM_alloc()</a>) is automatically added to the registration list, and further processes can become registered for the same buffer by way of the <a class="el" href="group__ti___c_m_e_m.html#ga02a5098376cfc8d2936350723d712ad9" title="Register shared usage of an already-allocated buffer.">CMEM_registerAlloc()</a> API (and unregister with the <a class="el" href="group__ti___c_m_e_m.html#gadccb25f3cfcb630015f946fdfa481c8a" title="Unregister use of a buffer previously registered with CMEM_registerAlloc().">CMEM_unregister()</a> API). This registration list for each buffer allows for buffer ownership tracking and cleanup on a per-file-descriptor basis, so that when a process exits or dies without having explicitly freed/unregistered its buffers, they get automatically unregistered (and freed when no more registered file descriptors exist). Only when the last registered file descriptor frees a buffer (either explictily, or by auto-cleanup) does a buffer actually get freed back to the kernel module.</p>
<h2>CMA access</h2>
<p>On systems with CMA (Contiguous Memory Allocator) support, CMEM can be used to allocate CMA buffers. Both heap and pool allocations are supported. A special block ID, CMEM_CMABLOCKID, is used for these allocations, and therefore the block-based CMEM APIs must be used (the ones ending in "2", such as <a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831" title="Allocate memory of a specified size from a specified memory block.">CMEM_alloc2()</a>), where the 'blockid' parameter is CMEM_CMABLOCKID (instead of 0 or 1).</p>
<p>CMA always contains, at the minimum, a global area that can be accessed by any device driver. CMEM treats this global area as a heap, which means that heap-based allocations can be performed on CMEM_CMABLOCKID. See the Linux CMA documentation for details on specifying this global area. Keep in mind that other Linux kernel entities can (and will) also allocate memory from this global area, so you never really know how much is available for allocations by CMEM.</p>
<p>To achieve pool-based allocations from CMA, a special CMEM stub must be builtin to the kernel, and CMEM must be built with CMEM_KERNEL_STUB=1 for the 'make' command (which turns into -DCMEM_KERNEL_STUB on the compile command). This stub processes a kernel command line parameter named "cmem_cma_pools=..." in the same fashion as the standard CMEM "pools=...". A separate CMA region (area) is created for each of the separate "cmem_cma_pools" (where each pool/region is one element of the comma- separated list).</p>
<p>The CMEM builtin kernel stub is located in &lt;linuxutils&gt;/src/cmem/module/kernel/drivers/cmem/cmemk_stub.c You don't need this stub if you want to allocate only from the CMA global area. Please see comments at the head of the above file for instructions on how to incorporate it into your kernel.</p>
<p>In supporting the pool model of CMEM, a separate CMA region is created for each pool. A pool consists of n buffers of size s, resulting in a region that is sized accordingly. CMA places no restrictions on the size of an allocation from a region, so the buffer size 's' becomes more of a convention than a hard rule. Given enough free space, any pool can be used to allocate a buffer of any size, but it is recommended to partition regions (or, in this case, pools) according to the size of buffers that will be allocated in order to reduce fragmentation and wasted memory due to size-based alignment padding. In other words, if your system will be allocating buffers of sizes 4096, 131072, and 1048576, create pools of cmem_cma_pools=&lt;n1&gt;x4096,&lt;n2&gt;x131072,&lt;n3&gt;x1048576 and perform allocations from the respective pool.</p>
<p>An application doesn't need to know the pool IDs that correspond to the respective sizes of that pool's buffers. The <a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831" title="Allocate memory of a specified size from a specified memory block.">CMEM_alloc2()</a> API decides which pool to use according to the requested size of allocation, and will choose the one that fits most efficiently. Unlike non-CMA pool allocations where, when the "best fit" pool has no remaining buffers it will choose a pool with larger available buffers, <a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831" title="Allocate memory of a specified size from a specified memory block.">CMEM_alloc2()</a> won't "promote" a CMA-based pool allocation to a pool with buffers larger than the the best fit.</p>
<p>CMEM supports a kernel command line parameter named "cmem_cma_heapsize". When assigned, a CMA region of size "cmem_cma_heapsize" is created for use by CMEM heap allocations for the CMA "block". This heap is then used for CMEM CMA heap allocations, and the CMA global area is no longer used by CMEM. This allows CMEM to have full usage of the CMEM CMA heap without possible allocations by non-CMEM entities in the kernel. </p>
</div>
<p><a href="cmem_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <a class="el" href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a" title="Allocate memory of a specified size.">CMEM_alloc()</a>, <a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831" title="Allocate memory of a specified size from a specified memory block.">CMEM_alloc2()</a>, <a class="el" href="group__ti___c_m_e_m.html#ga8def9ca65d0e48320525a12326686877" title="Allocate memory from a specified pool.">CMEM_allocPool()</a>, <a class="el" href="group__ti___c_m_e_m.html#ga209562d2562a6a6f3ddcce162f835468" title="Allocate memory from a specified pool in a specified memory block.">CMEM_allocPool2()</a>, <a class="el" href="group__ti___c_m_e_m.html#gae39f01bac7c437e9738090bef4aed158" title="Free a buffer previously allocated with CMEM_alloc()/CMEM_allocPool().">CMEM_free()</a>.  <a href="struct_c_m_e_m___alloc_params.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_m_e_m___block_attrs.html">CMEM_BlockAttrs</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga742e77191f1efd05c9a4f3ffa247d7da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga742e77191f1efd05c9a4f3ffa247d7da">CMEM_VERSION</a>&#160;&#160;&#160;0x04000000U</td></tr>
<tr class="memitem:ga30d4a34597a7dabfeefbffe42a8c29c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga30d4a34597a7dabfeefbffe42a8c29c9">MAX_POOLS</a>&#160;&#160;&#160;32</td></tr>
<tr class="memitem:ga5e886504ad1fa82d26eccda0773d9c32"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga5e886504ad1fa82d26eccda0773d9c32">CMEM_CMABLOCKID</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memitem:ga187e4e9bf672a30c82a7b70b60542754"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga187e4e9bf672a30c82a7b70b60542754">CMEM_WB</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memitem:ga84a13cfa52f98f56f979096a0b97f44c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga84a13cfa52f98f56f979096a0b97f44c">CMEM_INV</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memitem:gae6df4f615573af4d9c8186384d180d84"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gae6df4f615573af4d9c8186384d180d84">CMEM_HEAP</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="memitem:ga1131d153a198e8a45b480e2694c0aa56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga1131d153a198e8a45b480e2694c0aa56">CMEM_POOL</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memitem:ga894220a7ad3f4fe58272fa57e5716ff7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga894220a7ad3f4fe58272fa57e5716ff7">CMEM_CACHED</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memitem:ga50734833b9ef3a67e48d94d1e4cd1271"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga50734833b9ef3a67e48d94d1e4cd1271">CMEM_NONCACHED</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memitem:ga9006bc536abeccec35c020f9bea41605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga9006bc536abeccec35c020f9bea41605">CMEM_PHYS</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="memitem:gabd02db44a1dac13174ae356f4c4ce230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gabd02db44a1dac13174ae356f4c4ce230">CMEM_IOCMAGIC</a>&#160;&#160;&#160;0x0000fe00</td></tr>
<tr class="memitem:gac1fd168739bd05307ec519d2d254f14a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gac1fd168739bd05307ec519d2d254f14a">CMEM_IOCALLOC</a>&#160;&#160;&#160;1</td></tr>
<tr class="memitem:ga17cdd5932da87a6ceebd53eeaccfcdf5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga17cdd5932da87a6ceebd53eeaccfcdf5">CMEM_IOCALLOCHEAP</a>&#160;&#160;&#160;2</td></tr>
<tr class="memitem:ga3e5c2aa4938172852878743681f1deec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga3e5c2aa4938172852878743681f1deec">CMEM_IOCFREE</a>&#160;&#160;&#160;3</td></tr>
<tr class="memitem:ga9bcdafb23157f060882296536f662620"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga9bcdafb23157f060882296536f662620">CMEM_IOCGETPHYS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memitem:ga10a20aac6f8b10639d9f904004b7b3b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga10a20aac6f8b10639d9f904004b7b3b7">CMEM_IOCGETSIZE</a>&#160;&#160;&#160;5</td></tr>
<tr class="memitem:gaa949ce903361352e2cc69a93b6a1bea1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaa949ce903361352e2cc69a93b6a1bea1">CMEM_IOCGETPOOL</a>&#160;&#160;&#160;6</td></tr>
<tr class="memitem:ga741576815e673fba2253028be1ed886d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga741576815e673fba2253028be1ed886d">CMEM_IOCCACHE</a>&#160;&#160;&#160;7</td></tr>
<tr class="memitem:ga70664ef0aefedc53dc697baeec46a20d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga70664ef0aefedc53dc697baeec46a20d">CMEM_IOCGETVERSION</a>&#160;&#160;&#160;8</td></tr>
<tr class="memitem:ga21a43bb3db137d462e3bff278c574da4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga21a43bb3db137d462e3bff278c574da4">CMEM_IOCGETBLOCK</a>&#160;&#160;&#160;9</td></tr>
<tr class="memitem:ga925be32918be15c2204b0cebe5921dec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga925be32918be15c2204b0cebe5921dec">CMEM_IOCREGUSER</a>&#160;&#160;&#160;10</td></tr>
<tr class="memitem:ga386afee541b1c310a05855e34766459b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga386afee541b1c310a05855e34766459b">CMEM_IOCGETNUMBLOCKS</a>&#160;&#160;&#160;11</td></tr>
<tr class="memitem:ga6588f2a6e6d151c881574296e1fa7c75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga6588f2a6e6d151c881574296e1fa7c75">CMEM_IOCCACHEWBINV</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga741576815e673fba2253028be1ed886d">CMEM_IOCCACHE</a> | <a class="el" href="group__ti___c_m_e_m.html#ga187e4e9bf672a30c82a7b70b60542754">CMEM_WB</a> | <a class="el" href="group__ti___c_m_e_m.html#ga84a13cfa52f98f56f979096a0b97f44c">CMEM_INV</a></td></tr>
<tr class="memitem:gaa8cb1794d3f8a650da956dbc827ffa04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaa8cb1794d3f8a650da956dbc827ffa04">CMEM_IOCCACHEWB</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga741576815e673fba2253028be1ed886d">CMEM_IOCCACHE</a> | <a class="el" href="group__ti___c_m_e_m.html#ga187e4e9bf672a30c82a7b70b60542754">CMEM_WB</a></td></tr>
<tr class="memitem:gae3599cdcb42c124e1ba590eca5c79d56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gae3599cdcb42c124e1ba590eca5c79d56">CMEM_IOCCACHEINV</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga741576815e673fba2253028be1ed886d">CMEM_IOCCACHE</a> | <a class="el" href="group__ti___c_m_e_m.html#ga84a13cfa52f98f56f979096a0b97f44c">CMEM_INV</a></td></tr>
<tr class="memitem:gae46dd092114a9907c62d1af0d0a8282f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gae46dd092114a9907c62d1af0d0a8282f">CMEM_IOCALLOCCACHED</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#gac1fd168739bd05307ec519d2d254f14a">CMEM_IOCALLOC</a> | <a class="el" href="group__ti___c_m_e_m.html#ga894220a7ad3f4fe58272fa57e5716ff7">CMEM_CACHED</a></td></tr>
<tr class="memitem:ga1f666e24302dd5f9d8489f1ab916aef3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga1f666e24302dd5f9d8489f1ab916aef3">CMEM_IOCALLOCHEAPCACHED</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga17cdd5932da87a6ceebd53eeaccfcdf5">CMEM_IOCALLOCHEAP</a> | <a class="el" href="group__ti___c_m_e_m.html#ga894220a7ad3f4fe58272fa57e5716ff7">CMEM_CACHED</a></td></tr>
<tr class="memitem:ga41ee50820ad343b3b591e0ad38e5764d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga41ee50820ad343b3b591e0ad38e5764d">CMEM_IOCFREEHEAP</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga3e5c2aa4938172852878743681f1deec">CMEM_IOCFREE</a> | <a class="el" href="group__ti___c_m_e_m.html#gae6df4f615573af4d9c8186384d180d84">CMEM_HEAP</a></td></tr>
<tr class="memitem:gad0d90d49e48e01a48490010a583f59f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gad0d90d49e48e01a48490010a583f59f1">CMEM_IOCFREEPHYS</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga3e5c2aa4938172852878743681f1deec">CMEM_IOCFREE</a> | <a class="el" href="group__ti___c_m_e_m.html#ga9006bc536abeccec35c020f9bea41605">CMEM_PHYS</a></td></tr>
<tr class="memitem:gad1d6271519a725d94b29f2d096b6d898"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gad1d6271519a725d94b29f2d096b6d898">CMEM_IOCFREEHEAPPHYS</a>&#160;&#160;&#160;<a class="el" href="group__ti___c_m_e_m.html#ga3e5c2aa4938172852878743681f1deec">CMEM_IOCFREE</a> | <a class="el" href="group__ti___c_m_e_m.html#gae6df4f615573af4d9c8186384d180d84">CMEM_HEAP</a> | <a class="el" href="group__ti___c_m_e_m.html#ga9006bc536abeccec35c020f9bea41605">CMEM_PHYS</a></td></tr>
<tr class="memitem:ga60adf021b05573125be11ca3af825564"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga60adf021b05573125be11ca3af825564">CMEM_IOCCMDMASK</a>&#160;&#160;&#160;0x000000ff</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf772e1cf0334dca4e2cbb1acb1fa7a74"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaf772e1cf0334dca4e2cbb1acb1fa7a74">CMEM_AllocParams</a></td></tr>
<tr class="memdesc:gaf772e1cf0334dca4e2cbb1acb1fa7a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <a class="el" href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a" title="Allocate memory of a specified size.">CMEM_alloc()</a>, <a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831" title="Allocate memory of a specified size from a specified memory block.">CMEM_alloc2()</a>, <a class="el" href="group__ti___c_m_e_m.html#ga8def9ca65d0e48320525a12326686877" title="Allocate memory from a specified pool.">CMEM_allocPool()</a>, <a class="el" href="group__ti___c_m_e_m.html#ga209562d2562a6a6f3ddcce162f835468" title="Allocate memory from a specified pool in a specified memory block.">CMEM_allocPool2()</a>, <a class="el" href="group__ti___c_m_e_m.html#gae39f01bac7c437e9738090bef4aed158" title="Free a buffer previously allocated with CMEM_alloc()/CMEM_allocPool().">CMEM_free()</a>.  <a href="group__ti___c_m_e_m.html#gaf772e1cf0334dca4e2cbb1acb1fa7a74"></a><br/></td></tr>
<tr class="memitem:gab599820b841ce7113113c618fb0e8a85"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_m_e_m___block_attrs.html">CMEM_BlockAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gab599820b841ce7113113c618fb0e8a85">CMEM_BlockAttrs</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga04a13119b1d6100b93b9d3476d42f915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga04a13119b1d6100b93b9d3476d42f915">CMEM_init</a> (void)</td></tr>
<tr class="memdesc:ga04a13119b1d6100b93b9d3476d42f915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the CMEM module. Must be called before other API calls.  <a href="group__ti___c_m_e_m.html#ga04a13119b1d6100b93b9d3476d42f915"></a><br/></td></tr>
<tr class="memitem:ga61b4561b4f8e9c01a84b2ccd4d4c8531"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga61b4561b4f8e9c01a84b2ccd4d4c8531">CMEM_getPool</a> (size_t size)</td></tr>
<tr class="memdesc:ga61b4561b4f8e9c01a84b2ccd4d4c8531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pool that best fits a given buffer size and has a buffer available.  <a href="group__ti___c_m_e_m.html#ga61b4561b4f8e9c01a84b2ccd4d4c8531"></a><br/></td></tr>
<tr class="memitem:ga7923345b21ea4baf38f3b4a4c6a8ecf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga7923345b21ea4baf38f3b4a4c6a8ecf7">CMEM_getPool2</a> (int blockid, size_t size)</td></tr>
<tr class="memdesc:ga7923345b21ea4baf38f3b4a4c6a8ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pool in memory block blockid that best fits a given buffer size and has a buffer available.  <a href="group__ti___c_m_e_m.html#ga7923345b21ea4baf38f3b4a4c6a8ecf7"></a><br/></td></tr>
<tr class="memitem:ga8def9ca65d0e48320525a12326686877"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga8def9ca65d0e48320525a12326686877">CMEM_allocPool</a> (int poolid, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:ga8def9ca65d0e48320525a12326686877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from a specified pool.  <a href="group__ti___c_m_e_m.html#ga8def9ca65d0e48320525a12326686877"></a><br/></td></tr>
<tr class="memitem:ga209562d2562a6a6f3ddcce162f835468"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga209562d2562a6a6f3ddcce162f835468">CMEM_allocPool2</a> (int blockid, int poolid, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:ga209562d2562a6a6f3ddcce162f835468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory from a specified pool in a specified memory block.  <a href="group__ti___c_m_e_m.html#ga209562d2562a6a6f3ddcce162f835468"></a><br/></td></tr>
<tr class="memitem:gaa8f06de969151e59379f7491b7c58b4a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a">CMEM_alloc</a> (size_t size, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:gaa8f06de969151e59379f7491b7c58b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory of a specified size.  <a href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a"></a><br/></td></tr>
<tr class="memitem:gaa246effe37bc6dafa7146c443c83e831"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831">CMEM_alloc2</a> (int blockid, size_t size, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:gaa246effe37bc6dafa7146c443c83e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory of a specified size from a specified memory block.  <a href="group__ti___c_m_e_m.html#gaa246effe37bc6dafa7146c443c83e831"></a><br/></td></tr>
<tr class="memitem:ga02a5098376cfc8d2936350723d712ad9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga02a5098376cfc8d2936350723d712ad9">CMEM_registerAlloc</a> (off_t physp)</td></tr>
<tr class="memdesc:ga02a5098376cfc8d2936350723d712ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register shared usage of an already-allocated buffer.  <a href="group__ti___c_m_e_m.html#ga02a5098376cfc8d2936350723d712ad9"></a><br/></td></tr>
<tr class="memitem:gae39f01bac7c437e9738090bef4aed158"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gae39f01bac7c437e9738090bef4aed158">CMEM_free</a> (void *ptr, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:gae39f01bac7c437e9738090bef4aed158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a buffer previously allocated with <a class="el" href="group__ti___c_m_e_m.html#gaa8f06de969151e59379f7491b7c58b4a" title="Allocate memory of a specified size.">CMEM_alloc()</a>/CMEM_allocPool().  <a href="group__ti___c_m_e_m.html#gae39f01bac7c437e9738090bef4aed158"></a><br/></td></tr>
<tr class="memitem:gadccb25f3cfcb630015f946fdfa481c8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gadccb25f3cfcb630015f946fdfa481c8a">CMEM_unregister</a> (void *ptr, <a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a> *params)</td></tr>
<tr class="memdesc:gadccb25f3cfcb630015f946fdfa481c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister use of a buffer previously registered with <a class="el" href="group__ti___c_m_e_m.html#ga02a5098376cfc8d2936350723d712ad9" title="Register shared usage of an already-allocated buffer.">CMEM_registerAlloc()</a>.  <a href="group__ti___c_m_e_m.html#gadccb25f3cfcb630015f946fdfa481c8a"></a><br/></td></tr>
<tr class="memitem:gaccb7428817085e56d482f2c722a6e35a"><td class="memItemLeft" align="right" valign="top">off_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaccb7428817085e56d482f2c722a6e35a">CMEM_getPhys</a> (void *ptr)</td></tr>
<tr class="memdesc:gaccb7428817085e56d482f2c722a6e35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical address of a contiguous buffer.  <a href="group__ti___c_m_e_m.html#gaccb7428817085e56d482f2c722a6e35a"></a><br/></td></tr>
<tr class="memitem:gaeef3fdc1bf833b34017c975a477dc278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaeef3fdc1bf833b34017c975a477dc278">CMEM_cacheWb</a> (void *ptr, size_t size)</td></tr>
<tr class="memdesc:gaeef3fdc1bf833b34017c975a477dc278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a cache writeback of the block pointed to by <code>ptr/<code>size</code>.</code>  <a href="group__ti___c_m_e_m.html#gaeef3fdc1bf833b34017c975a477dc278"></a><br/></td></tr>
<tr class="memitem:gaf1a3b3217f091db1d05aa4c1a2cf596a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaf1a3b3217f091db1d05aa4c1a2cf596a">CMEM_cacheInv</a> (void *ptr, size_t size)</td></tr>
<tr class="memdesc:gaf1a3b3217f091db1d05aa4c1a2cf596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a cache invalidate of the block pointed to by <code>ptr/<code>size</code>.</code>  <a href="group__ti___c_m_e_m.html#gaf1a3b3217f091db1d05aa4c1a2cf596a"></a><br/></td></tr>
<tr class="memitem:ga749afac6dc4077f4c7f947593497929e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga749afac6dc4077f4c7f947593497929e">CMEM_cacheWbInv</a> (void *ptr, size_t size)</td></tr>
<tr class="memdesc:ga749afac6dc4077f4c7f947593497929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a cache writeback/invalidate of the block pointed to by <code>ptr/<code>size</code>.</code>  <a href="group__ti___c_m_e_m.html#ga749afac6dc4077f4c7f947593497929e"></a><br/></td></tr>
<tr class="memitem:gae4c4df4bae7464ffddd3f21b0815c10e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gae4c4df4bae7464ffddd3f21b0815c10e">CMEM_getVersion</a> (void)</td></tr>
<tr class="memdesc:gae4c4df4bae7464ffddd3f21b0815c10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve version from CMEM driver.  <a href="group__ti___c_m_e_m.html#gae4c4df4bae7464ffddd3f21b0815c10e"></a><br/></td></tr>
<tr class="memitem:ga02a6e5c68d1d1048533905e3e9c5d60d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga02a6e5c68d1d1048533905e3e9c5d60d">CMEM_getBlock</a> (off_t *pphys_base, size_t *psize)</td></tr>
<tr class="memdesc:ga02a6e5c68d1d1048533905e3e9c5d60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve memory block bounds from CMEM driver.  <a href="group__ti___c_m_e_m.html#ga02a6e5c68d1d1048533905e3e9c5d60d"></a><br/></td></tr>
<tr class="memitem:gaf5bfc403676da91ecf44242d525afd8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#gaf5bfc403676da91ecf44242d525afd8b">CMEM_getBlockAttrs</a> (int blockid, <a class="el" href="struct_c_m_e_m___block_attrs.html">CMEM_BlockAttrs</a> *pattrs)</td></tr>
<tr class="memdesc:gaf5bfc403676da91ecf44242d525afd8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve extended memory block attributes from CMEM driver.  <a href="group__ti___c_m_e_m.html#gaf5bfc403676da91ecf44242d525afd8b"></a><br/></td></tr>
<tr class="memitem:ga5604844605a5e32dd4f242798b30dc09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga5604844605a5e32dd4f242798b30dc09">CMEM_getNumBlocks</a> (int *pnblocks)</td></tr>
<tr class="memdesc:ga5604844605a5e32dd4f242798b30dc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve number of blocks configured into CMEM driver.  <a href="group__ti___c_m_e_m.html#ga5604844605a5e32dd4f242798b30dc09"></a><br/></td></tr>
<tr class="memitem:ga98363a0c4114e0227fbc1763203177b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga98363a0c4114e0227fbc1763203177b9">CMEM_exit</a> (void)</td></tr>
<tr class="memdesc:ga98363a0c4114e0227fbc1763203177b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize the CMEM module.  <a href="group__ti___c_m_e_m.html#ga98363a0c4114e0227fbc1763203177b9"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga02f27b513787b9581ebd67ff62827904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_m_e_m___alloc_params.html">CMEM_AllocParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ti___c_m_e_m.html#ga02f27b513787b9581ebd67ff62827904">CMEM_DEFAULTPARAMS</a></td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2013, Texas Instruments Incorporated
</small>
</body>
</html>
<!--
/*
 * @(#) linuxutils_4_00_00_06; 1, 0, 0,1; 7-12-2013 08:22:37; /db/atree/library/trees/linuxutils/linuxutils-m06/src/ xlibrary

 */
-->

